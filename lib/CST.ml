(* Generated by ocaml-tree-sitter. *)
(*
   julia grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type float_literal = Token.t
[@@deriving sexp_of]

type pat_684220d = Token.t (* pattern "[^'\\\\]" *)
[@@deriving sexp_of]

type dotty_operator = Token.t
[@@deriving sexp_of]

type pat_a25c544 = Token.t (* pattern [0-9]|([0-9][0-9_]*[0-9]) *)
[@@deriving sexp_of]

type command_start = Token.t
[@@deriving sexp_of]

type tok_0b_pat_1c3450e = Token.t
[@@deriving sexp_of]

type immediate_paren = Token.t
[@@deriving sexp_of]

type escape_sequence = Token.t
[@@deriving sexp_of]

type immediate_string_start = Token.t
[@@deriving sexp_of]

type imm_tok_lbrack = Token.t (* "[" *)
[@@deriving sexp_of]

type rational_operator = Token.t
[@@deriving sexp_of]

type command_end = Token.t
[@@deriving sexp_of]

type comparison_operator = Token.t
[@@deriving sexp_of]

type identifier =
  Token.t (* pattern "[_\\p{L}\\p{Nl}\226\136\135][^\"'`\\s\\.\\-\\[\\],;:(){}&$=+==*=/=//=\\\\=^=\195\183=%=<<=>>=>>>=|=&=\226\138\187=\226\137\148\226\169\180\226\137\149\226\134\144\226\134\146\226\134\148\226\134\154\226\134\155\226\134\158\226\134\160\226\134\162\226\134\163\226\134\166\226\134\164\226\134\174\226\135\142\226\135\141\226\135\143\226\135\144\226\135\146\226\135\148\226\135\180\226\135\182\226\135\183\226\135\184\226\135\185\226\135\186\226\135\187\226\135\188\226\135\189\226\135\190\226\135\191\226\159\181\226\159\182\226\159\183\226\159\185\226\159\186\226\159\187\226\159\188\226\159\189\226\159\190\226\159\191\226\164\128\226\164\129\226\164\130\226\164\131\226\164\132\226\164\133\226\164\134\226\164\135\226\164\140\226\164\141\226\164\142\226\164\143\226\164\144\226\164\145\226\164\148\226\164\149\226\164\150\226\164\151\226\164\152\226\164\157\226\164\158\226\164\159\226\164\160\226\165\132\226\165\133\226\165\134\226\165\135\226\165\136\226\165\138\226\165\139\226\165\142\226\165\144\226\165\146\226\165\147\226\165\150\226\165\151\226\165\154\226\165\155\226\165\158\226\165\159\226\165\162\226\165\164\226\165\166\226\165\167\226\165\168\226\165\169\226\165\170\226\165\171\226\165\172\226\165\173\226\165\176\226\167\180\226\172\177\226\172\176\226\172\178\226\172\179\226\172\180\226\172\181\226\172\182\226\172\183\226\172\184\226\172\185\226\172\186\226\172\187\226\172\188\226\172\189\226\172\190\226\172\191\226\173\128\226\173\129\226\173\130\226\173\131\226\173\132\226\173\135\226\173\136\226\173\137\226\173\138\226\173\139\226\173\140\239\191\169\239\191\171\226\135\156\226\135\157\226\134\156\226\134\157\226\134\169\226\134\170\226\134\171\226\134\172\226\134\188\226\134\189\226\135\128\226\135\129\226\135\132\226\135\134\226\135\135\226\135\137\226\135\139\226\135\140\226\135\154\226\135\155\226\135\160\226\135\162><>=\226\137\165<=\226\137\164=====\226\137\161=\226\137\160==\226\137\162\226\136\136\226\136\137\226\136\139\226\136\140\226\138\134\226\138\136\226\138\130\226\138\132\226\138\138\226\136\157\226\136\138\226\136\141\226\136\165\226\136\166\226\136\183\226\136\186\226\136\187\226\136\189\226\136\190\226\137\129\226\137\131\226\137\130\226\137\132\226\137\133\226\137\134\226\137\135\226\137\136\226\137\137\226\137\138\226\137\139\226\137\140\226\137\141\226\137\142\226\137\144\226\137\145\226\137\146\226\137\147\226\137\150\226\137\151\226\137\152\226\137\153\226\137\154\226\137\155\226\137\156\226\137\157\226\137\158\226\137\159\226\137\163\226\137\166\226\137\167\226\137\168\226\137\169\226\137\170\226\137\171\226\137\172\226\137\173\226\137\174\226\137\175\226\137\176\226\137\177\226\137\178\226\137\179\226\137\180\226\137\181\226\137\182\226\137\183\226\137\184\226\137\185\226\137\186\226\137\187\226\137\188\226\137\189\226\137\190\226\137\191\226\138\128\226\138\129\226\138\131\226\138\133\226\138\135\226\138\137\226\138\139\226\138\143\226\138\144\226\138\145\226\138\146\226\138\156\226\138\169\226\138\172\226\138\174\226\138\176\226\138\177\226\138\178\226\138\179\226\138\180\226\138\181\226\138\182\226\138\183\226\139\141\226\139\144\226\139\145\226\139\149\226\139\150\226\139\151\226\139\152\226\139\153\226\139\154\226\139\155\226\139\156\226\139\157\226\139\158\226\139\159\226\139\160\226\139\161\226\139\162\226\139\163\226\139\164\226\139\165\226\139\166\226\139\167\226\139\168\226\139\169\226\139\170\226\139\171\226\139\172\226\139\173\226\139\178\226\139\179\226\139\180\226\139\181\226\139\182\226\139\183\226\139\184\226\139\185\226\139\186\226\139\187\226\139\188\226\139\189\226\139\190\226\139\191\226\159\136\226\159\137\226\159\146\226\166\183\226\167\128\226\167\129\226\167\161\226\167\163\226\167\164\226\167\165\226\169\166\226\169\167\226\169\170\226\169\171\226\169\172\226\169\173\226\169\174\226\169\175\226\169\176\226\169\177\226\169\178\226\169\179\226\169\181\226\169\182\226\169\183\226\169\184\226\169\185\226\169\186\226\169\187\226\169\188\226\169\189\226\169\190\226\169\191\226\170\128\226\170\129\226\170\130\226\170\131\226\170\132\226\170\133\226\170\134\226\170\135\226\170\136\226\170\137\226\170\138\226\170\139\226\170\140\226\170\141\226\170\142\226\170\143\226\170\144\226\170\145\226\170\146\226\170\147\226\170\148\226\170\149\226\170\150\226\170\151\226\170\152\226\170\153\226\170\154\226\170\155\226\170\156\226\170\157\226\170\158\226\170\159\226\170\160\226\170\161\226\170\162\226\170\163\226\170\164\226\170\165\226\170\166\226\170\167\226\170\168\226\170\169\226\170\170\226\170\171\226\170\172\226\170\173\226\170\174\226\170\175\226\170\176\226\170\177\226\170\178\226\170\179\226\170\180\226\170\181\226\170\182\226\170\183\226\170\184\226\170\185\226\170\186\226\170\187\226\170\188\226\170\189\226\170\190\226\170\191\226\171\128\226\171\129\226\171\130\226\171\131\226\171\132\226\171\133\226\171\134\226\171\135\226\171\136\226\171\137\226\171\138\226\171\139\226\171\140\226\171\141\226\171\142\226\171\143\226\171\144\226\171\145\226\171\146\226\171\147\226\171\148\226\171\149\226\171\150\226\171\151\226\171\152\226\171\153\226\171\183\226\171\184\226\171\185\226\171\186\226\138\162\226\138\163\226\159\130\226\128\166\226\129\157\226\139\174\226\139\177\226\139\176\226\139\175+|\226\138\149\226\138\150\226\138\158\226\138\159++\226\136\170\226\136\168\226\138\148\194\177\226\136\147\226\136\148\226\136\184\226\137\130\226\137\143\226\138\142\226\138\187\226\138\189\226\139\142\226\139\147\226\167\186\226\167\187\226\168\136\226\168\162\226\168\163\226\168\164\226\168\165\226\168\166\226\168\167\226\168\168\226\168\169\226\168\170\226\168\171\226\168\172\226\168\173\226\168\174\226\168\185\226\168\186\226\169\129\226\169\130\226\169\133\226\169\138\226\169\140\226\169\143\226\169\144\226\169\146\226\169\148\226\169\150\226\169\151\226\169\155\226\169\157\226\169\161\226\169\162\226\169\163*/\195\183%&\226\139\133\226\136\152\195\151\\\\\226\136\169\226\136\167\226\138\151\226\138\152\226\138\153\226\138\154\226\138\155\226\138\160\226\138\161\226\138\147\226\136\151\226\136\153\226\136\164\226\133\139\226\137\128\226\138\188\226\139\132\226\139\134\226\139\135\226\139\137\226\139\138\226\139\139\226\139\140\226\139\143\226\139\146\226\159\145\226\166\184\226\166\188\226\166\190\226\166\191\226\167\182\226\167\183\226\168\135\226\168\176\226\168\177\226\168\178\226\168\179\226\168\180\226\168\181\226\168\182\226\168\183\226\168\184\226\168\187\226\168\188\226\168\189\226\169\128\226\169\131\226\169\132\226\169\139\226\169\141\226\169\142\226\169\145\226\169\147\226\169\149\226\169\152\226\169\154\226\169\156\226\169\158\226\169\159\226\169\160\226\171\155\226\138\141\226\150\183\226\168\157\226\159\149\226\159\150\226\159\151<<>>>>>^\226\134\145\226\134\147\226\135\181\226\159\176\226\159\177\226\164\136\226\164\137\226\164\138\226\164\139\226\164\146\226\164\147\226\165\137\226\165\140\226\165\141\226\165\143\226\165\145\226\165\148\226\165\149\226\165\152\226\165\153\226\165\156\226\165\157\226\165\160\226\165\161\226\165\163\226\165\165\226\165\174\226\165\175\239\191\170\239\191\172]*" *)
[@@deriving sexp_of]

type plus_operator = Token.t
[@@deriving sexp_of]

type string_content_no_interp = Token.t
[@@deriving sexp_of]

type assign_operator = Token.t
[@@deriving sexp_of]

type unary_operator = Token.t
[@@deriving sexp_of]

type immediate_command_start = Token.t
[@@deriving sexp_of]

type tok_0x_pat_50ed65e = Token.t
[@@deriving sexp_of]

type times_operator = Token.t
[@@deriving sexp_of]

type arrow_operator = Token.t
[@@deriving sexp_of]

type power_operator = Token.t
[@@deriving sexp_of]

type string_end = Token.t
[@@deriving sexp_of]

type string_start = Token.t
[@@deriving sexp_of]

type tok_0o_pat_c83427c = Token.t
[@@deriving sexp_of]

type string_content = Token.t
[@@deriving sexp_of]

type bitshift_operator = Token.t
[@@deriving sexp_of]

type terminator = [ `LF of Token.t (* "\n" *) | `SEMI of Token.t (* ";" *) ]
[@@deriving sexp_of]

type imm_tok_colon = Token.t (* ":" *)
[@@deriving sexp_of]

type anon_choice_id_f1f5a37 = [
    `Id of identifier (*tok*)
  | `Scoped_id of scoped_identifier
]

and scoped_identifier = (
    anon_choice_id_f1f5a37 option
  * Token.t (* "." *)
  * identifier (*tok*)
)
[@@deriving sexp_of]

type anon_choice_str_content_no_interp_24ac4f9 = [
    `Str_content_no_interp of string_content_no_interp (*tok*)
  | `Esc_seq of escape_sequence (*tok*)
]
[@@deriving sexp_of]

type integer_literal = [
    `Tok_0b_pat_1c3450e of tok_0b_pat_1c3450e
  | `Tok_0o_pat_c83427c of tok_0o_pat_c83427c
  | `Tok_0x_pat_50ed65e of tok_0x_pat_50ed65e
  | `Pat_a25c544 of pat_a25c544
]
[@@deriving sexp_of]

type operator = [
    `Comp_op of comparison_operator (*tok*)
  | `Dotty_op of dotty_operator (*tok*)
  | `Plus_op of plus_operator (*tok*)
  | `Times_op of times_operator (*tok*)
  | `Rati_op of rational_operator (*tok*)
  | `Bits_op of bitshift_operator (*tok*)
  | `Power_op of power_operator (*tok*)
  | `Un_op of unary_operator (*tok*)
]
[@@deriving sexp_of]

type macro_identifier = (
    Token.t (* "@" *)
  * [
        `Id of identifier (*tok*)
      | `Op of operator
      | `DOT of Token.t (* "." *)
    ]
)
[@@deriving sexp_of]

type anon_choice_id_8e9135e = [
    `Id of identifier (*tok*)
  | `Macro_id of macro_identifier
]
[@@deriving sexp_of]

type anon_choice_id_1ca53ff = [
    `Id of identifier (*tok*)
  | `Scoped_id of scoped_identifier
  | `Sele_import of (
        anon_choice_id_f1f5a37
      * imm_tok_colon (*tok*)
      * anon_choice_id_8e9135e
      * (Token.t (* "," *) * anon_choice_id_8e9135e) list (* zero or more *)
    )
]
[@@deriving sexp_of]

type anon_choice_arg_list_38b50f0 = [
    `Arg_list of argument_list
  | `Gene_exp of generator_expression
]

and anon_choice_exp_44a61a9 = [
    `Exp of expression
  | `Assign_exp of assignment_expression
]

and anon_choice_exp_91c2553 = [
    `Exp of expression
  | `Named_field of named_field
]

and anon_choice_exp_b71eb95 = [
    `Exp of expression
  | `Assign_exp of assignment_expression
  | `Bare_tuple_exp of bare_tuple_expression
]

and anon_choice_exp_d189641 = [
    `Exp of expression
  | `Bare_tuple_exp of bare_tuple_expression
]

and anon_choice_id_0836987 = [
    `Id of identifier (*tok*)
  | `Spread_param of (identifier (*tok*) * Token.t (* "..." *))
  | `Opt_param of (
        [ `Id of identifier (*tok*) | `Typed_param of typed_parameter ]
      * Token.t (* "=" *)
      * expression
    )
  | `Typed_param of typed_parameter
]

and anon_choice_id_b4fe4b3 = [
    `Id of identifier (*tok*)
  | `Para_id of parameterized_identifier
]

and anon_choice_id_e9e133c = [
    `Id of identifier (*tok*)
  | `Cons_param of (identifier (*tok*) * Token.t (* "<:" *) * expression)
]

and anon_choice_str_content_838a78d = [
    `Str_content of string_content (*tok*)
  | `Str_interp of (
        Token.t (* "$" *)
      * [
            `Id of identifier (*tok*)
          | `LPAR_exp_RPAR of (
                Token.t (* "(" *) * expression * Token.t (* ")" *)
            )
        ]
    )
  | `Esc_seq of escape_sequence (*tok*)
]

and anon_exp_rep_COMMA_exp_0bb260c = (
    expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
)

and argument_list = (
    Token.t (* "(" *)
  * (
        anon_choice_exp_91c2553
      * (Token.t (* "," *) * anon_choice_exp_91c2553) list (* zero or more *)
    )
      option
  * (
        Token.t (* ";" *)
      * named_field
      * (Token.t (* "," *) * named_field) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and assignment_expression = (
    anon_choice_exp_d189641
  * [ `Assign_op of assign_operator (*tok*) | `EQ of Token.t (* "=" *) ]
  * anon_choice_exp_b71eb95
)

and bare_tuple_expression = (
    expression
  * (Token.t (* "," *) * expression) list (* one or more *)
)

and binary_expression = [
    `Exp_power_op_exp of (expression * power_operator (*tok*) * expression)
  | `Exp_rati_op_exp of (expression * rational_operator (*tok*) * expression)
  | `Exp_bits_op_exp of (expression * bitshift_operator (*tok*) * expression)
  | `Exp_times_op_exp of (expression * times_operator (*tok*) * expression)
  | `Exp_choice_PLUS_exp of (
        expression
      * [ `PLUS of Token.t (* "+" *) | `Plus_op of plus_operator (*tok*) ]
      * expression
    )
  | `Exp_dotty_op_exp of (expression * dotty_operator (*tok*) * expression)
  | `Exp_arrow_op_exp of (expression * arrow_operator (*tok*) * expression)
  | `Exp_LTBAR_exp of (expression * Token.t (* "<|" *) * expression)
  | `Exp_BARGT_exp of (expression * Token.t (* "|>" *) * expression)
  | `Exp_choice_in_exp of (
        expression
      * [
            `In of Token.t (* "in" *)
          | `Isa of Token.t (* "isa" *)
          | `Comp_op of comparison_operator (*tok*)
        ]
      * expression
    )
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
]

and catch_clause = (
    Token.t (* "catch" *)
  * identifier (*tok*) option
  * terminator option
  * source_file
)

and comprehension_clause = (
    for_clause
  * [ `For_clause of for_clause | `If_clause of if_clause ]
      list (* zero or more *)
)

and definition = [
    `Abst_defi of (
        Token.t (* "abstract" *)
      * Token.t (* "type" *)
      * identifier (*tok*)
      * type_parameter_list option
      * subtype_clause option
      * Token.t (* "end" *)
    )
  | `Prim_defi of (
        Token.t (* "primitive" *)
      * Token.t (* "type" *)
      * identifier (*tok*)
      * type_parameter_list option
      * subtype_clause option
      * pat_a25c544
      * Token.t (* "end" *)
    )
  | `Struct_defi of (
        Token.t (* "mutable" *) option
      * Token.t (* "struct" *)
      * identifier (*tok*)
      * type_parameter_list option
      * subtype_clause option
      * source_file
      * Token.t (* "end" *)
    )
  | `Module_defi of (
        Token.t (* "module" *) * identifier (*tok*) * source_file
      * Token.t (* "end" *)
    )
  | `Func_defi of (
        Token.t (* "function" *)
      * identifier (*tok*)
      * type_parameter_list option
      * parameter_list
      * source_file
      * Token.t (* "end" *)
    )
  | `Macro_defi of (
        Token.t (* "macro" *)
      * [ `Id of identifier (*tok*) | `Op of operator ]
      * parameter_list
      * source_file
      * Token.t (* "end" *)
    )
]

and do_clause = (Token.t (* "do" *) * expression_list * Token.t (* "end" *))

and else_clause = (Token.t (* "else" *) * source_file)

and elseif_clause = (
    Token.t (* "elseif" *)
  * expression
  * terminator option
  * source_file
)

and expression = [
    `Choice_if_stmt of statement
  | `Choice_abst_defi of definition
  | `Typed_exp of (
        expression
      * [
            `COLONCOLON of Token.t (* "::" *)
          | `LTCOLON of Token.t (* "<:" *)
        ]
      * anon_choice_id_b4fe4b3
    )
  | `Comp_exp of (
        Token.t (* "begin" *) * expression_list * Token.t (* "end" *)
    )
  | `Pair_exp of (expression * Token.t (* "=>" *) * expression)
  | `COLON of Token.t (* ":" *)
  | `Macro_exp of (
        macro_identifier
      * [
            `Imme_paren_arg_list of (immediate_paren (*tok*) * argument_list)
          | `Macro_arg_list of macro_argument_list
        ]
          option
    )
  | `Un_exp of unary_expression
  | `Bin_exp of binary_expression
  | `Tern_exp of (
        expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
      * expression
    )
  | `Gene_exp of generator_expression
  | `Func_exp of function_expression
  | `Coef_exp of (
        [ `Pat_a25c544 of pat_a25c544 | `Float_lit of float_literal (*tok*) ]
      * [
            `Paren_exp of parenthesized_expression
          | `Id of identifier (*tok*)
        ]
    )
  | `Spread_exp of spread_expression
  | `Range_exp of (expression * Token.t (* ":" *) * expression)
  | `Quote_exp of (Token.t (* ":" *) * expression)
  | `Interp_exp of (Token.t (* "$" *) * expression)
  | `Prim_exp of primary_expression
  | `Lit of literal
  | `Op of operator
]

and expression_list = (
    anon_choice_exp_b71eb95
  * (terminator * anon_choice_exp_b71eb95) list (* zero or more *)
  * terminator option
)

and field_expression = (
    primary_expression * Token.t (* "." *) * identifier (*tok*)
)

and finally_clause = (
    Token.t (* "finally" *)
  * terminator option
  * source_file
)

and for_binding = (
    [ `Id of identifier (*tok*) | `Tuple_exp of tuple_expression ]
  * [
        `In of Token.t (* "in" *)
      | `EQ of Token.t (* "=" *)
      | `UNKUNKUNK of Token.t (* "\226\136\136" *)
    ]
  * expression
)

and for_clause = (
    Token.t (* "for" *)
  * for_binding
  * (Token.t (* "," *) * for_binding) list (* zero or more *)
)

and function_expression = [
    `Func_param_list_choice_exp_end of (
        Token.t (* "function" *) * parameter_list * anon_choice_exp_44a61a9
      * Token.t (* "end" *)
    )
  | `Choice_id_DASHGT_choice_exp of (
        [ `Id of identifier (*tok*) | `Param_list of parameter_list ]
      * Token.t (* "->" *)
      * anon_choice_exp_44a61a9
    )
]

and generator_expression = (
    Token.t (* "(" *) * expression * comprehension_clause * Token.t (* ")" *)
)

and if_clause = (Token.t (* "if" *) * expression)

and keyword_parameters = (
    Token.t (* ";" *)
  * anon_choice_id_0836987
  * (Token.t (* "," *) * anon_choice_id_0836987) list (* zero or more *)
)

and literal = [
    `Int_lit of integer_literal
  | `Float_lit of float_literal (*tok*)
  | `Char_lit of (
        Token.t (* "'" *)
      * [ `Esc_seq of escape_sequence (*tok*) | `Pat_684220d of pat_684220d ]
      * Token.t (* "'" *)
    )
  | `Str_lit of (
        string_start (*tok*)
      * anon_choice_str_content_838a78d list (* zero or more *)
      * string_end (*tok*)
    )
  | `Cmd_lit of (
        command_start (*tok*)
      * anon_choice_str_content_838a78d list (* zero or more *)
      * command_end (*tok*)
    )
  | `Pref_str_lit of (
        identifier (*tok*)
      * immediate_string_start (*tok*)
      * anon_choice_str_content_no_interp_24ac4f9 list (* zero or more *)
      * string_end (*tok*)
    )
  | `Pref_cmd_lit of (
        identifier (*tok*)
      * immediate_command_start (*tok*)
      * anon_choice_str_content_no_interp_24ac4f9 list (* zero or more *)
      * command_end (*tok*)
    )
]

and macro_argument_list = expression list (* one or more *)

and matrix_row = expression list (* one or more *)

and named_field = (identifier (*tok*) * Token.t (* "=" *) * expression)

and parameter_list = (
    Token.t (* "(" *)
  * (
        anon_choice_id_0836987
      * (Token.t (* "," *) * anon_choice_id_0836987) list (* zero or more *)
    )
      option
  * keyword_parameters option
  * Token.t (* ")" *)
)

and parameterized_identifier = (
    [ `Id of identifier (*tok*) | `Field_exp of field_expression ]
  * type_argument_list
)

and parenthesized_expression = (
    Token.t (* "(" *)
  * [ `Exp_list of expression_list | `Spread_exp of spread_expression ]
  * Token.t (* ")" *)
)

and primary_expression = [
    `Id of identifier (*tok*)
  | `Array_exp of (
        Token.t (* "[" *)
      * anon_exp_rep_COMMA_exp_0bb260c option
      * Token.t (* "," *) option
      * Token.t (* "]" *)
    )
  | `Array_comp_exp of (
        Token.t (* "[" *) * expression * comprehension_clause
      * Token.t (* "]" *)
    )
  | `Matrix_exp of (
        Token.t (* "[" *)
      * (
            matrix_row
          * (Token.t (* ";" *) * matrix_row) list (* zero or more *)
        )
          option
      * Token.t (* ";" *) option
      * Token.t (* "]" *)
    )
  | `Call_exp of (
        [ `Prim_exp of primary_expression | `Op of operator ]
      * immediate_paren (*tok*)
      * anon_choice_arg_list_38b50f0
      * do_clause option
    )
  | `Field_exp of field_expression
  | `Paren_exp of parenthesized_expression
  | `Subs_exp of (
        [ `Prim_exp of primary_expression | `Lit of literal ]
      * imm_tok_lbrack (*tok*)
      * anon_exp_rep_COMMA_exp_0bb260c option
      * Token.t (* "," *) option
      * Token.t (* "]" *)
    )
  | `Para_id of parameterized_identifier
  | `Tuple_exp of tuple_expression
  | `Broa_call_exp of (
        primary_expression
      * Token.t (* "." *)
      * immediate_paren (*tok*)
      * anon_choice_arg_list_38b50f0
      * do_clause option
    )
]

and source_file = expression_list option

and spread_expression = (expression * Token.t (* "..." *))

and statement = [
    `If_stmt of (
        Token.t (* "if" *)
      * expression
      * terminator option
      * source_file
      * elseif_clause list (* zero or more *)
      * else_clause option
      * Token.t (* "end" *)
    )
  | `Try_stmt of (
        Token.t (* "try" *)
      * source_file
      * catch_clause option
      * finally_clause option
      * Token.t (* "end" *)
    )
  | `For_stmt of (
        Token.t (* "for" *)
      * for_binding
      * (Token.t (* "," *) * for_binding) list (* zero or more *)
      * terminator option
      * source_file
      * Token.t (* "end" *)
    )
  | `While_stmt of (
        Token.t (* "while" *)
      * expression
      * terminator option
      * source_file
      * Token.t (* "end" *)
    )
  | `Let_stmt of (
        Token.t (* "let" *)
      * variable_declaration
      * (Token.t (* "," *) * variable_declaration) list (* zero or more *)
      * terminator option
      * source_file
      * Token.t (* "end" *)
    )
  | `Const_stmt of (
        Token.t (* "const" *)
      * variable_declaration
      * (Token.t (* "," *) * variable_declaration) list (* zero or more *)
    )
  | `Quote_stmt of (
        Token.t (* "quote" *) * source_file * Token.t (* "end" *)
    )
  | `Brk_stmt of Token.t (* "break" *)
  | `Cont_stmt of Token.t (* "continue" *)
  | `Ret_stmt of (Token.t (* "return" *) * anon_choice_exp_d189641 option)
  | `Import_stmt of (
        [
            `Using of Token.t (* "using" *)
          | `Import of Token.t (* "import" *)
        ]
      * anon_choice_id_1ca53ff
      * (Token.t (* "," *) * anon_choice_id_1ca53ff) list (* zero or more *)
    )
  | `Export_stmt of (
        Token.t (* "export" *)
      * identifier (*tok*)
      * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
    )
]

and subtype_clause = (Token.t (* "<:" *) * expression)

and tuple_expression = (
    Token.t (* "(" *)
  * [
        `Opt_COMMA of Token.t (* "," *) option
      | `Choice_exp_COMMA of (anon_choice_exp_91c2553 * Token.t (* "," *))
      | `Choice_exp_rep1_COMMA_choice_exp_opt_COMMA of (
            anon_choice_exp_91c2553
          * (Token.t (* "," *) * anon_choice_exp_91c2553)
              list (* one or more *)
          * Token.t (* "," *) option
        )
    ]
  * Token.t (* ")" *)
)

and type_argument_list = (
    Token.t (* "{" *)
  * [ `Exp of expression ]
  * (Token.t (* "," *) * [ `Exp of expression ]) list (* zero or more *)
  * Token.t (* "}" *)
)

and type_parameter_list = (
    Token.t (* "{" *)
  * anon_choice_id_e9e133c
  * (Token.t (* "," *) * anon_choice_id_e9e133c) list (* zero or more *)
  * Token.t (* "}" *)
)

and typed_parameter = (
    identifier (*tok*) * Token.t (* "::" *) * anon_choice_id_b4fe4b3
)

and unary_expression = [
    `Un_op_exp of (unary_operator (*tok*) * expression)
  | `Exp_SQUOT of (expression * Token.t (* "'" *))
]

and variable_declaration = (
    identifier (*tok*)
  * (Token.t (* "=" *) * expression) option
)
[@@deriving sexp_of]

type continue_statement (* inlined *) = Token.t (* "continue" *)
[@@deriving sexp_of]

type block_comment (* inlined *) = Token.t
[@@deriving sexp_of]

type break_statement (* inlined *) = Token.t (* "break" *)
[@@deriving sexp_of]

type line_comment (* inlined *) = Token.t
[@@deriving sexp_of]

type character_literal (* inlined *) = (
    Token.t (* "'" *)
  * [ `Esc_seq of escape_sequence (*tok*) | `Pat_684220d of pat_684220d ]
  * Token.t (* "'" *)
)
[@@deriving sexp_of]

type export_statement (* inlined *) = (
    Token.t (* "export" *)
  * identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
)
[@@deriving sexp_of]

type spread_parameter (* inlined *) = (
    identifier (*tok*) * Token.t (* "..." *)
)
[@@deriving sexp_of]

type prefixed_command_literal (* inlined *) = (
    identifier (*tok*)
  * immediate_command_start (*tok*)
  * anon_choice_str_content_no_interp_24ac4f9 list (* zero or more *)
  * command_end (*tok*)
)
[@@deriving sexp_of]

type prefixed_string_literal (* inlined *) = (
    identifier (*tok*)
  * immediate_string_start (*tok*)
  * anon_choice_str_content_no_interp_24ac4f9 list (* zero or more *)
  * string_end (*tok*)
)
[@@deriving sexp_of]

type selected_import (* inlined *) = (
    anon_choice_id_f1f5a37
  * imm_tok_colon (*tok*)
  * anon_choice_id_8e9135e
  * (Token.t (* "," *) * anon_choice_id_8e9135e) list (* zero or more *)
)
[@@deriving sexp_of]

type import_statement (* inlined *) = (
    [ `Using of Token.t (* "using" *) | `Import of Token.t (* "import" *) ]
  * anon_choice_id_1ca53ff
  * (Token.t (* "," *) * anon_choice_id_1ca53ff) list (* zero or more *)
)
[@@deriving sexp_of]

type abstract_definition (* inlined *) = (
    Token.t (* "abstract" *)
  * Token.t (* "type" *)
  * identifier (*tok*)
  * type_parameter_list option
  * subtype_clause option
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

type array_comprehension_expression (* inlined *) = (
    Token.t (* "[" *) * expression * comprehension_clause * Token.t (* "]" *)
)
[@@deriving sexp_of]

type array_expression (* inlined *) = (
    Token.t (* "[" *)
  * anon_exp_rep_COMMA_exp_0bb260c option
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type broadcast_call_expression (* inlined *) = (
    primary_expression
  * Token.t (* "." *)
  * immediate_paren (*tok*)
  * anon_choice_arg_list_38b50f0
  * do_clause option
)
[@@deriving sexp_of]

type call_expression (* inlined *) = (
    [ `Prim_exp of primary_expression | `Op of operator ]
  * immediate_paren (*tok*)
  * anon_choice_arg_list_38b50f0
  * do_clause option
)
[@@deriving sexp_of]

type coefficient_expression (* inlined *) = (
    [ `Pat_a25c544 of pat_a25c544 | `Float_lit of float_literal (*tok*) ]
  * [ `Paren_exp of parenthesized_expression | `Id of identifier (*tok*) ]
)
[@@deriving sexp_of]

type command_literal (* inlined *) = (
    command_start (*tok*)
  * anon_choice_str_content_838a78d list (* zero or more *)
  * command_end (*tok*)
)
[@@deriving sexp_of]

type compound_expression (* inlined *) = (
    Token.t (* "begin" *) * expression_list * Token.t (* "end" *)
)
[@@deriving sexp_of]

type const_statement (* inlined *) = (
    Token.t (* "const" *)
  * variable_declaration
  * (Token.t (* "," *) * variable_declaration) list (* zero or more *)
)
[@@deriving sexp_of]

type constrained_parameter (* inlined *) = (
    identifier (*tok*) * Token.t (* "<:" *) * expression
)
[@@deriving sexp_of]

type for_statement (* inlined *) = (
    Token.t (* "for" *)
  * for_binding
  * (Token.t (* "," *) * for_binding) list (* zero or more *)
  * terminator option
  * source_file
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

type function_definition (* inlined *) = (
    Token.t (* "function" *)
  * identifier (*tok*)
  * type_parameter_list option
  * parameter_list
  * source_file
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

type if_statement (* inlined *) = (
    Token.t (* "if" *)
  * expression
  * terminator option
  * source_file
  * elseif_clause list (* zero or more *)
  * else_clause option
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

type interpolation_expression (* inlined *) = (
    Token.t (* "$" *) * expression
)
[@@deriving sexp_of]

type let_statement (* inlined *) = (
    Token.t (* "let" *)
  * variable_declaration
  * (Token.t (* "," *) * variable_declaration) list (* zero or more *)
  * terminator option
  * source_file
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

type macro_definition (* inlined *) = (
    Token.t (* "macro" *)
  * [ `Id of identifier (*tok*) | `Op of operator ]
  * parameter_list
  * source_file
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

type macro_expression (* inlined *) = (
    macro_identifier
  * [
        `Imme_paren_arg_list of (immediate_paren (*tok*) * argument_list)
      | `Macro_arg_list of macro_argument_list
    ]
      option
)
[@@deriving sexp_of]

type matrix_expression (* inlined *) = (
    Token.t (* "[" *)
  * (matrix_row * (Token.t (* ";" *) * matrix_row) list (* zero or more *))
      option
  * Token.t (* ";" *) option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type module_definition (* inlined *) = (
    Token.t (* "module" *) * identifier (*tok*) * source_file
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

type optional_parameter (* inlined *) = (
    [ `Id of identifier (*tok*) | `Typed_param of typed_parameter ]
  * Token.t (* "=" *)
  * expression
)
[@@deriving sexp_of]

type pair_expression (* inlined *) = (
    expression * Token.t (* "=>" *) * expression
)
[@@deriving sexp_of]

type primitive_definition (* inlined *) = (
    Token.t (* "primitive" *)
  * Token.t (* "type" *)
  * identifier (*tok*)
  * type_parameter_list option
  * subtype_clause option
  * pat_a25c544
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

type quote_expression (* inlined *) = (Token.t (* ":" *) * expression)
[@@deriving sexp_of]

type quote_statement (* inlined *) = (
    Token.t (* "quote" *) * source_file * Token.t (* "end" *)
)
[@@deriving sexp_of]

type range_expression (* inlined *) = (
    expression * Token.t (* ":" *) * expression
)
[@@deriving sexp_of]

type return_statement (* inlined *) = (
    Token.t (* "return" *)
  * anon_choice_exp_d189641 option
)
[@@deriving sexp_of]

type string_interpolation (* inlined *) = (
    Token.t (* "$" *)
  * [
        `Id of identifier (*tok*)
      | `LPAR_exp_RPAR of (
            Token.t (* "(" *) * expression * Token.t (* ")" *)
        )
    ]
)
[@@deriving sexp_of]

type string_literal (* inlined *) = (
    string_start (*tok*)
  * anon_choice_str_content_838a78d list (* zero or more *)
  * string_end (*tok*)
)
[@@deriving sexp_of]

type struct_definition (* inlined *) = (
    Token.t (* "mutable" *) option
  * Token.t (* "struct" *)
  * identifier (*tok*)
  * type_parameter_list option
  * subtype_clause option
  * source_file
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

type subscript_expression (* inlined *) = (
    [ `Prim_exp of primary_expression | `Lit of literal ]
  * imm_tok_lbrack (*tok*)
  * anon_exp_rep_COMMA_exp_0bb260c option
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type ternary_expression (* inlined *) = (
    expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
  * expression
)
[@@deriving sexp_of]

type try_statement (* inlined *) = (
    Token.t (* "try" *)
  * source_file
  * catch_clause option
  * finally_clause option
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

type typed_expression (* inlined *) = (
    expression
  * [ `COLONCOLON of Token.t (* "::" *) | `LTCOLON of Token.t (* "<:" *) ]
  * anon_choice_id_b4fe4b3
)
[@@deriving sexp_of]

type while_statement (* inlined *) = (
    Token.t (* "while" *)
  * expression
  * terminator option
  * source_file
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_source_file root
  |> Print_sexp.to_stdout
