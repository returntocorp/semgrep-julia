(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_julia"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "line_comment";
  "block_comment";
]

let children_regexps : (string * Run.exp option) list = [
  "imm_tok_lbrack", None;
  "power_operator", None;
  "float_literal", None;
  "dotty_operator", None;
  "command_start", None;
  "tok_0b_pat_1c3450e", None;
  "arrow_operator", None;
  "bitshift_operator", None;
  "identifier", None;
  "immediate_string_start", None;
  "comparison_operator", None;
  "escape_sequence", None;
  "immediate_command_start", None;
  "imm_tok_colon", None;
  "string_content_no_interp", None;
  "pat_684220d", None;
  "unary_operator", None;
  "pat_a25c544", None;
  "tok_0x_pat_50ed65e", None;
  "times_operator", None;
  "break_statement", None;
  "rational_operator", None;
  "string_end", None;
  "continue_statement", None;
  "string_start", None;
  "tok_0o_pat_c83427c", None;
  "string_content", None;
  "command_end", None;
  "plus_operator", None;
  "assign_operator", None;
  "immediate_paren", None;
  "export_statement",
  Some (
    Seq [
      Token (Literal "export");
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "scoped_identifier",
  Some (
    Seq [
      Opt (
        Alt [|
          Token (Name "identifier");
          Token (Name "scoped_identifier");
        |];
      );
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "spread_parameter",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "...");
    ];
  );
  "character_literal",
  Some (
    Seq [
      Token (Literal "'");
      Alt [|
        Token (Name "escape_sequence");
        Token (Name "pat_684220d");
      |];
      Token (Literal "'");
    ];
  );
  "prefixed_string_literal",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Name "immediate_string_start");
      Repeat (
        Alt [|
          Token (Name "string_content_no_interp");
          Token (Name "escape_sequence");
        |];
      );
      Token (Name "string_end");
    ];
  );
  "integer_literal",
  Some (
    Alt [|
      Token (Name "tok_0b_pat_1c3450e");
      Token (Name "tok_0o_pat_c83427c");
      Token (Name "tok_0x_pat_50ed65e");
      Token (Name "pat_a25c544");
    |];
  );
  "prefixed_command_literal",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Name "immediate_command_start");
      Repeat (
        Alt [|
          Token (Name "string_content_no_interp");
          Token (Name "escape_sequence");
        |];
      );
      Token (Name "command_end");
    ];
  );
  "operator",
  Some (
    Alt [|
      Token (Name "comparison_operator");
      Token (Name "dotty_operator");
      Token (Name "plus_operator");
      Token (Name "times_operator");
      Token (Name "rational_operator");
      Token (Name "bitshift_operator");
      Token (Name "power_operator");
      Token (Name "unary_operator");
    |];
  );
  "macro_identifier",
  Some (
    Seq [
      Token (Literal "@");
      Alt [|
        Token (Name "identifier");
        Token (Name "operator");
        Token (Literal ".");
      |];
    ];
  );
  "selected_import",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_identifier");
      |];
      Token (Name "imm_tok_colon");
      Alt [|
        Token (Name "identifier");
        Token (Name "macro_identifier");
      |];
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "identifier");
            Token (Name "macro_identifier");
          |];
        ];
      );
    ];
  );
  "import_statement",
  Some (
    Seq [
      Alt [|
        Token (Literal "using");
        Token (Literal "import");
      |];
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_identifier");
        Token (Name "selected_import");
      |];
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "identifier");
            Token (Name "scoped_identifier");
            Token (Name "selected_import");
          |];
        ];
      );
    ];
  );
  "abstract_definition",
  Some (
    Seq [
      Token (Literal "abstract");
      Token (Literal "type");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameter_list");
      );
      Opt (
        Token (Name "subtype_clause");
      );
      Token (Literal "end");
    ];
  );
  "argument_list",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Alt [|
            Token (Name "expression");
            Token (Name "named_field");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "expression");
                Token (Name "named_field");
              |];
            ];
          );
        ];
      );
      Opt (
        Seq [
          Token (Literal ";");
          Token (Name "named_field");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "named_field");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ")");
    ];
  );
  "array_comprehension_expression",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "expression");
      Token (Name "comprehension_clause");
      Token (Literal "]");
    ];
  );
  "array_expression",
  Some (
    Seq [
      Token (Literal "[");
      Opt (
        Seq [
          Token (Name "expression");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expression");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "]");
    ];
  );
  "assignment_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "expression");
        Token (Name "bare_tuple_expression");
      |];
      Alt [|
        Token (Name "assign_operator");
        Token (Literal "=");
      |];
      Alt [|
        Token (Name "expression");
        Token (Name "assignment_expression");
        Token (Name "bare_tuple_expression");
      |];
    ];
  );
  "bare_tuple_expression",
  Some (
    Seq [
      Token (Name "expression");
      Repeat1 (
        Seq [
          Token (Literal ",");
          Token (Name "expression");
        ];
      );
    ];
  );
  "binary_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Name "power_operator");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Name "rational_operator");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Name "bitshift_operator");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Name "times_operator");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "+");
          Token (Name "plus_operator");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Name "dotty_operator");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Name "arrow_operator");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<|");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "|>");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "in");
          Token (Literal "isa");
          Token (Name "comparison_operator");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "||");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "&&");
        Token (Name "expression");
      ];
    |];
  );
  "broadcast_call_expression",
  Some (
    Seq [
      Token (Name "primary_expression");
      Token (Literal ".");
      Token (Name "immediate_paren");
      Alt [|
        Token (Name "argument_list");
        Token (Name "generator_expression");
      |];
      Opt (
        Token (Name "do_clause");
      );
    ];
  );
  "call_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "primary_expression");
        Token (Name "operator");
      |];
      Token (Name "immediate_paren");
      Alt [|
        Token (Name "argument_list");
        Token (Name "generator_expression");
      |];
      Opt (
        Token (Name "do_clause");
      );
    ];
  );
  "catch_clause",
  Some (
    Seq [
      Token (Literal "catch");
      Opt (
        Token (Name "identifier");
      );
      Opt (
        Alt [|
          Token (Literal "\n");
          Token (Literal ";");
        |];
      );
      Opt (
        Token (Name "expression_list");
      );
    ];
  );
  "coefficient_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "pat_a25c544");
        Token (Name "float_literal");
      |];
      Alt [|
        Token (Name "parenthesized_expression");
        Token (Name "identifier");
      |];
    ];
  );
  "command_literal",
  Some (
    Seq [
      Token (Name "command_start");
      Repeat (
        Alt [|
          Token (Name "string_content");
          Token (Name "string_interpolation");
          Token (Name "escape_sequence");
        |];
      );
      Token (Name "command_end");
    ];
  );
  "compound_expression",
  Some (
    Seq [
      Token (Literal "begin");
      Token (Name "expression_list");
      Token (Literal "end");
    ];
  );
  "comprehension_clause",
  Some (
    Seq [
      Token (Name "for_clause");
      Repeat (
        Alt [|
          Token (Name "for_clause");
          Token (Name "if_clause");
        |];
      );
    ];
  );
  "const_statement",
  Some (
    Seq [
      Token (Literal "const");
      Token (Name "variable_declaration");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "variable_declaration");
        ];
      );
    ];
  );
  "constrained_parameter",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "<:");
      Token (Name "expression");
    ];
  );
  "do_clause",
  Some (
    Seq [
      Token (Literal "do");
      Token (Name "expression_list");
      Token (Literal "end");
    ];
  );
  "else_clause",
  Some (
    Seq [
      Token (Literal "else");
      Opt (
        Token (Name "expression_list");
      );
    ];
  );
  "elseif_clause",
  Some (
    Seq [
      Token (Literal "elseif");
      Token (Name "expression");
      Opt (
        Alt [|
          Token (Literal "\n");
          Token (Literal ";");
        |];
      );
      Opt (
        Token (Name "expression_list");
      );
    ];
  );
  "expression",
  Some (
    Alt [|
      Alt [|
        Token (Name "if_statement");
        Token (Name "try_statement");
        Token (Name "for_statement");
        Token (Name "while_statement");
        Token (Name "let_statement");
        Token (Name "const_statement");
        Token (Name "quote_statement");
        Token (Name "break_statement");
        Token (Name "continue_statement");
        Token (Name "return_statement");
        Token (Name "import_statement");
        Token (Name "export_statement");
      |];
      Alt [|
        Token (Name "abstract_definition");
        Token (Name "primitive_definition");
        Token (Name "struct_definition");
        Token (Name "module_definition");
        Token (Name "function_definition");
        Token (Name "macro_definition");
      |];
      Token (Name "typed_expression");
      Token (Name "compound_expression");
      Token (Name "pair_expression");
      Token (Literal ":");
      Token (Name "macro_expression");
      Token (Name "unary_expression");
      Token (Name "binary_expression");
      Token (Name "ternary_expression");
      Token (Name "generator_expression");
      Token (Name "function_expression");
      Token (Name "coefficient_expression");
      Token (Name "spread_expression");
      Token (Name "range_expression");
      Token (Name "quote_expression");
      Token (Name "interpolation_expression");
      Token (Name "primary_expression");
      Token (Name "literal");
      Token (Name "operator");
    |];
  );
  "expression_list",
  Some (
    Seq [
      Alt [|
        Token (Name "expression");
        Token (Name "assignment_expression");
        Token (Name "bare_tuple_expression");
      |];
      Repeat (
        Seq [
          Alt [|
            Token (Literal "\n");
            Token (Literal ";");
          |];
          Alt [|
            Token (Name "expression");
            Token (Name "assignment_expression");
            Token (Name "bare_tuple_expression");
          |];
        ];
      );
      Opt (
        Alt [|
          Token (Literal "\n");
          Token (Literal ";");
        |];
      );
    ];
  );
  "field_expression",
  Some (
    Seq [
      Token (Name "primary_expression");
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "finally_clause",
  Some (
    Seq [
      Token (Literal "finally");
      Opt (
        Alt [|
          Token (Literal "\n");
          Token (Literal ";");
        |];
      );
      Opt (
        Token (Name "expression_list");
      );
    ];
  );
  "for_binding",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "tuple_expression");
      |];
      Alt [|
        Token (Literal "in");
        Token (Literal "=");
        Token (Literal "\226\136\136");
      |];
      Token (Name "expression");
    ];
  );
  "for_clause",
  Some (
    Seq [
      Token (Literal "for");
      Token (Name "for_binding");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "for_binding");
        ];
      );
    ];
  );
  "for_statement",
  Some (
    Seq [
      Token (Literal "for");
      Token (Name "for_binding");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "for_binding");
        ];
      );
      Opt (
        Alt [|
          Token (Literal "\n");
          Token (Literal ";");
        |];
      );
      Opt (
        Token (Name "expression_list");
      );
      Token (Literal "end");
    ];
  );
  "function_definition",
  Some (
    Seq [
      Token (Literal "function");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameter_list");
      );
      Token (Name "parameter_list");
      Opt (
        Token (Name "expression_list");
      );
      Token (Literal "end");
    ];
  );
  "function_expression",
  Some (
    Alt [|
      Seq [
        Token (Literal "function");
        Token (Name "parameter_list");
        Alt [|
          Token (Name "expression");
          Token (Name "assignment_expression");
        |];
        Token (Literal "end");
      ];
      Seq [
        Alt [|
          Token (Name "identifier");
          Token (Name "parameter_list");
        |];
        Token (Literal "->");
        Alt [|
          Token (Name "expression");
          Token (Name "assignment_expression");
        |];
      ];
    |];
  );
  "generator_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expression");
      Token (Name "comprehension_clause");
      Token (Literal ")");
    ];
  );
  "if_clause",
  Some (
    Seq [
      Token (Literal "if");
      Token (Name "expression");
    ];
  );
  "if_statement",
  Some (
    Seq [
      Token (Literal "if");
      Token (Name "expression");
      Opt (
        Alt [|
          Token (Literal "\n");
          Token (Literal ";");
        |];
      );
      Opt (
        Token (Name "expression_list");
      );
      Repeat (
        Token (Name "elseif_clause");
      );
      Opt (
        Token (Name "else_clause");
      );
      Token (Literal "end");
    ];
  );
  "interpolation_expression",
  Some (
    Seq [
      Token (Literal "$");
      Token (Name "expression");
    ];
  );
  "keyword_parameters",
  Some (
    Seq [
      Token (Literal ";");
      Alt [|
        Token (Name "identifier");
        Token (Name "spread_parameter");
        Token (Name "optional_parameter");
        Token (Name "typed_parameter");
      |];
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "identifier");
            Token (Name "spread_parameter");
            Token (Name "optional_parameter");
            Token (Name "typed_parameter");
          |];
        ];
      );
    ];
  );
  "let_statement",
  Some (
    Seq [
      Token (Literal "let");
      Token (Name "variable_declaration");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "variable_declaration");
        ];
      );
      Opt (
        Alt [|
          Token (Literal "\n");
          Token (Literal ";");
        |];
      );
      Opt (
        Token (Name "expression_list");
      );
      Token (Literal "end");
    ];
  );
  "literal",
  Some (
    Alt [|
      Token (Name "integer_literal");
      Token (Name "float_literal");
      Token (Name "character_literal");
      Token (Name "string_literal");
      Token (Name "command_literal");
      Token (Name "prefixed_string_literal");
      Token (Name "prefixed_command_literal");
    |];
  );
  "macro_argument_list",
  Some (
    Repeat1 (
      Token (Name "expression");
    );
  );
  "macro_definition",
  Some (
    Seq [
      Token (Literal "macro");
      Alt [|
        Token (Name "identifier");
        Token (Name "operator");
      |];
      Token (Name "parameter_list");
      Opt (
        Token (Name "expression_list");
      );
      Token (Literal "end");
    ];
  );
  "macro_expression",
  Some (
    Seq [
      Token (Name "macro_identifier");
      Opt (
        Alt [|
          Seq [
            Token (Name "immediate_paren");
            Token (Name "argument_list");
          ];
          Token (Name "macro_argument_list");
        |];
      );
    ];
  );
  "matrix_expression",
  Some (
    Seq [
      Token (Literal "[");
      Opt (
        Seq [
          Token (Name "matrix_row");
          Repeat (
            Seq [
              Token (Literal ";");
              Token (Name "matrix_row");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ";");
      );
      Token (Literal "]");
    ];
  );
  "matrix_row",
  Some (
    Repeat1 (
      Token (Name "expression");
    );
  );
  "module_definition",
  Some (
    Seq [
      Token (Literal "module");
      Token (Name "identifier");
      Opt (
        Token (Name "expression_list");
      );
      Token (Literal "end");
    ];
  );
  "named_field",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "optional_parameter",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "typed_parameter");
      |];
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "pair_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "=>");
      Token (Name "expression");
    ];
  );
  "parameter_list",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Alt [|
            Token (Name "identifier");
            Token (Name "spread_parameter");
            Token (Name "optional_parameter");
            Token (Name "typed_parameter");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "identifier");
                Token (Name "spread_parameter");
                Token (Name "optional_parameter");
                Token (Name "typed_parameter");
              |];
            ];
          );
        ];
      );
      Opt (
        Token (Name "keyword_parameters");
      );
      Token (Literal ")");
    ];
  );
  "parameterized_identifier",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "field_expression");
      |];
      Token (Name "type_argument_list");
    ];
  );
  "parenthesized_expression",
  Some (
    Seq [
      Token (Literal "(");
      Alt [|
        Token (Name "expression_list");
        Token (Name "spread_expression");
      |];
      Token (Literal ")");
    ];
  );
  "primary_expression",
  Some (
    Alt [|
      Token (Name "identifier");
      Token (Name "array_expression");
      Token (Name "array_comprehension_expression");
      Token (Name "matrix_expression");
      Token (Name "call_expression");
      Token (Name "field_expression");
      Token (Name "parenthesized_expression");
      Token (Name "subscript_expression");
      Token (Name "parameterized_identifier");
      Token (Name "tuple_expression");
      Token (Name "broadcast_call_expression");
    |];
  );
  "primitive_definition",
  Some (
    Seq [
      Token (Literal "primitive");
      Token (Literal "type");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameter_list");
      );
      Opt (
        Token (Name "subtype_clause");
      );
      Token (Name "pat_a25c544");
      Token (Literal "end");
    ];
  );
  "quote_expression",
  Some (
    Seq [
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "quote_statement",
  Some (
    Seq [
      Token (Literal "quote");
      Opt (
        Token (Name "expression_list");
      );
      Token (Literal "end");
    ];
  );
  "range_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "return_statement",
  Some (
    Seq [
      Token (Literal "return");
      Opt (
        Alt [|
          Token (Name "expression");
          Token (Name "bare_tuple_expression");
        |];
      );
    ];
  );
  "spread_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "...");
    ];
  );
  "string_interpolation",
  Some (
    Seq [
      Token (Literal "$");
      Alt [|
        Token (Name "identifier");
        Seq [
          Token (Literal "(");
          Token (Name "expression");
          Token (Literal ")");
        ];
      |];
    ];
  );
  "string_literal",
  Some (
    Seq [
      Token (Name "string_start");
      Repeat (
        Alt [|
          Token (Name "string_content");
          Token (Name "string_interpolation");
          Token (Name "escape_sequence");
        |];
      );
      Token (Name "string_end");
    ];
  );
  "struct_definition",
  Some (
    Seq [
      Opt (
        Token (Literal "mutable");
      );
      Token (Literal "struct");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameter_list");
      );
      Opt (
        Token (Name "subtype_clause");
      );
      Opt (
        Token (Name "expression_list");
      );
      Token (Literal "end");
    ];
  );
  "subscript_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "primary_expression");
        Token (Name "literal");
      |];
      Token (Name "imm_tok_lbrack");
      Opt (
        Seq [
          Token (Name "expression");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expression");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "]");
    ];
  );
  "subtype_clause",
  Some (
    Seq [
      Token (Literal "<:");
      Token (Name "expression");
    ];
  );
  "ternary_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "?");
      Token (Name "expression");
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "try_statement",
  Some (
    Seq [
      Token (Literal "try");
      Opt (
        Token (Name "expression_list");
      );
      Opt (
        Token (Name "catch_clause");
      );
      Opt (
        Token (Name "finally_clause");
      );
      Token (Literal "end");
    ];
  );
  "tuple_expression",
  Some (
    Seq [
      Token (Literal "(");
      Alt [|
        Opt (
          Token (Literal ",");
        );
        Seq [
          Alt [|
            Token (Name "expression");
            Token (Name "named_field");
          |];
          Token (Literal ",");
        ];
        Seq [
          Alt [|
            Token (Name "expression");
            Token (Name "named_field");
          |];
          Repeat1 (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "expression");
                Token (Name "named_field");
              |];
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      |];
      Token (Literal ")");
    ];
  );
  "type_argument_list",
  Some (
    Seq [
      Token (Literal "{");
      Alt [|
        Token (Name "expression");
      |];
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "expression");
          |];
        ];
      );
      Token (Literal "}");
    ];
  );
  "type_parameter_list",
  Some (
    Seq [
      Token (Literal "{");
      Alt [|
        Token (Name "identifier");
        Token (Name "constrained_parameter");
      |];
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "identifier");
            Token (Name "constrained_parameter");
          |];
        ];
      );
      Token (Literal "}");
    ];
  );
  "typed_expression",
  Some (
    Seq [
      Token (Name "expression");
      Alt [|
        Token (Literal "::");
        Token (Literal "<:");
      |];
      Alt [|
        Token (Name "identifier");
        Token (Name "parameterized_identifier");
      |];
    ];
  );
  "typed_parameter",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "::");
      Alt [|
        Token (Name "identifier");
        Token (Name "parameterized_identifier");
      |];
    ];
  );
  "unary_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "unary_operator");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "'");
      ];
    |];
  );
  "variable_declaration",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      );
    ];
  );
  "while_statement",
  Some (
    Seq [
      Token (Literal "while");
      Token (Name "expression");
      Opt (
        Alt [|
          Token (Literal "\n");
          Token (Literal ";");
        |];
      );
      Opt (
        Token (Name "expression_list");
      );
      Token (Literal "end");
    ];
  );
  "source_file",
  Some (
    Opt (
      Token (Name "expression_list");
    );
  );
]

let trans_imm_tok_lbrack ((kind, body) : mt) : CST.imm_tok_lbrack =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_power_operator ((kind, body) : mt) : CST.power_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_float_literal ((kind, body) : mt) : CST.float_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_dotty_operator ((kind, body) : mt) : CST.dotty_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_command_start ((kind, body) : mt) : CST.command_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tok_0b_pat_1c3450e ((kind, body) : mt) : CST.tok_0b_pat_1c3450e =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_arrow_operator ((kind, body) : mt) : CST.arrow_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_bitshift_operator ((kind, body) : mt) : CST.bitshift_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_immediate_string_start ((kind, body) : mt) : CST.immediate_string_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_comparison_operator ((kind, body) : mt) : CST.comparison_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_escape_sequence ((kind, body) : mt) : CST.escape_sequence =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_immediate_command_start ((kind, body) : mt) : CST.immediate_command_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_imm_tok_colon ((kind, body) : mt) : CST.imm_tok_colon =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_content_no_interp ((kind, body) : mt) : CST.string_content_no_interp =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_684220d ((kind, body) : mt) : CST.pat_684220d =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_unary_operator ((kind, body) : mt) : CST.unary_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_a25c544 ((kind, body) : mt) : CST.pat_a25c544 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tok_0x_pat_50ed65e ((kind, body) : mt) : CST.tok_0x_pat_50ed65e =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_times_operator ((kind, body) : mt) : CST.times_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_break_statement ((kind, body) : mt) : CST.break_statement =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_rational_operator ((kind, body) : mt) : CST.rational_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_end ((kind, body) : mt) : CST.string_end =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_continue_statement ((kind, body) : mt) : CST.continue_statement =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_start ((kind, body) : mt) : CST.string_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tok_0o_pat_c83427c ((kind, body) : mt) : CST.tok_0o_pat_c83427c =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_content ((kind, body) : mt) : CST.string_content =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_command_end ((kind, body) : mt) : CST.command_end =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_plus_operator ((kind, body) : mt) : CST.plus_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_assign_operator ((kind, body) : mt) : CST.assign_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_immediate_paren ((kind, body) : mt) : CST.immediate_paren =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_export_statement ((kind, body) : mt) : CST.export_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_scoped_identifier ((kind, body) : mt) : CST.scoped_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Id (
                      trans_identifier (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Scoped_id (
                      trans_scoped_identifier (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spread_parameter ((kind, body) : mt) : CST.spread_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_character_literal ((kind, body) : mt) : CST.character_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Esc_seq (
                  trans_escape_sequence (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Pat_684220d (
                  trans_pat_684220d (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_prefixed_string_literal ((kind, body) : mt) : CST.prefixed_string_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_identifier (Run.matcher_token v0),
            trans_immediate_string_start (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Str_content_no_interp (
                      trans_string_content_no_interp (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_string_end (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_integer_literal ((kind, body) : mt) : CST.integer_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Tok_0b_pat_1c3450e (
            trans_tok_0b_pat_1c3450e (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Tok_0o_pat_c83427c (
            trans_tok_0o_pat_c83427c (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Tok_0x_pat_50ed65e (
            trans_tok_0x_pat_50ed65e (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Pat_a25c544 (
            trans_pat_a25c544 (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_prefixed_command_literal ((kind, body) : mt) : CST.prefixed_command_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_identifier (Run.matcher_token v0),
            trans_immediate_command_start (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Str_content_no_interp (
                      trans_string_content_no_interp (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_command_end (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_operator ((kind, body) : mt) : CST.operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Comp_op (
            trans_comparison_operator (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Dotty_op (
            trans_dotty_operator (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Plus_op (
            trans_plus_operator (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Times_op (
            trans_times_operator (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Rati_op (
            trans_rational_operator (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Bits_op (
            trans_bitshift_operator (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Power_op (
            trans_power_operator (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Un_op (
            trans_unary_operator (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_macro_identifier ((kind, body) : mt) : CST.macro_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Op (
                  trans_operator (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `DOT (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_selected_import ((kind, body) : mt) : CST.selected_import =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_id (
                  trans_scoped_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_imm_tok_colon (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Macro_id (
                  trans_macro_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Id (
                            trans_identifier (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Macro_id (
                            trans_macro_identifier (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_import_statement ((kind, body) : mt) : CST.import_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Using (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Import (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_id (
                  trans_scoped_identifier (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Sele_import (
                  trans_selected_import (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Id (
                            trans_identifier (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Scoped_id (
                            trans_scoped_identifier (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Sele_import (
                            trans_selected_import (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_abstract_definition ((kind, body) : mt) : CST.abstract_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_parameter_list (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_subtype_clause (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_argument_list ((kind, body) : mt) : CST.argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Named_field (
                            trans_named_field (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Exp (
                                      trans_expression (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Named_field (
                                      trans_named_field (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_named_field (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_named_field (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_comprehension_expression ((kind, body) : mt) : CST.array_comprehension_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            trans_comprehension_clause (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_expression ((kind, body) : mt) : CST.array_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_expression (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_expression (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assignment_expression ((kind, body) : mt) : CST.assignment_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Bare_tuple_exp (
                  trans_bare_tuple_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `Assign_op (
                  trans_assign_operator (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `EQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v2 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Assign_exp (
                  trans_assignment_expression (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Bare_tuple_exp (
                  trans_bare_tuple_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bare_tuple_expression ((kind, body) : mt) : CST.bare_tuple_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_binary_expression ((kind, body) : mt) : CST.binary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_power_op_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  trans_power_operator (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_rati_op_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  trans_rational_operator (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Exp_bits_op_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  trans_bitshift_operator (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Exp_times_op_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  trans_times_operator (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Exp_choice_PLUS_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `PLUS (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Plus_op (
                        trans_plus_operator (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Exp_dotty_op_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  trans_dotty_operator (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Exp_arrow_op_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  trans_arrow_operator (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Exp_LTBAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Exp_BARGT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Exp_choice_in_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `In (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Isa (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `Comp_op (
                        trans_comparison_operator (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (10, v) ->
          `Exp_BARBAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (11, v) ->
          `Exp_AMPAMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_broadcast_call_expression ((kind, body) : mt) : CST.broadcast_call_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_primary_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_immediate_paren (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Arg_list (
                  trans_argument_list (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Gene_exp (
                  trans_generator_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_do_clause (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_expression ((kind, body) : mt) : CST.call_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Prim_exp (
                  trans_primary_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Op (
                  trans_operator (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_immediate_paren (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Arg_list (
                  trans_argument_list (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Gene_exp (
                  trans_generator_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_do_clause (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_catch_clause ((kind, body) : mt) : CST.catch_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_identifier (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `LF (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `SEMI (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_coefficient_expression ((kind, body) : mt) : CST.coefficient_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Pat_a25c544 (
                  trans_pat_a25c544 (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Float_lit (
                  trans_float_literal (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `Paren_exp (
                  trans_parenthesized_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_command_literal ((kind, body) : mt) : CST.command_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_command_start (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Str_content (
                      trans_string_content (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Str_interp (
                      trans_string_interpolation (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_command_end (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_compound_expression ((kind, body) : mt) : CST.compound_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression_list (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_comprehension_clause ((kind, body) : mt) : CST.comprehension_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_for_clause (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `For_clause (
                      trans_for_clause (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `If_clause (
                      trans_if_clause (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_const_statement ((kind, body) : mt) : CST.const_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_variable_declaration (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_variable_declaration (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constrained_parameter ((kind, body) : mt) : CST.constrained_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_do_clause ((kind, body) : mt) : CST.do_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression_list (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_else_clause ((kind, body) : mt) : CST.else_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_elseif_clause ((kind, body) : mt) : CST.elseif_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `LF (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `SEMI (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_if_stmt (
            (match v with
            | Alt (0, v) ->
                `If_stmt (
                  trans_if_statement (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Try_stmt (
                  trans_try_statement (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `For_stmt (
                  trans_for_statement (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `While_stmt (
                  trans_while_statement (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Let_stmt (
                  trans_let_statement (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `Const_stmt (
                  trans_const_statement (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Quote_stmt (
                  trans_quote_statement (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Brk_stmt (
                  trans_break_statement (Run.matcher_token v)
                )
            | Alt (8, v) ->
                `Cont_stmt (
                  trans_continue_statement (Run.matcher_token v)
                )
            | Alt (9, v) ->
                `Ret_stmt (
                  trans_return_statement (Run.matcher_token v)
                )
            | Alt (10, v) ->
                `Import_stmt (
                  trans_import_statement (Run.matcher_token v)
                )
            | Alt (11, v) ->
                `Export_stmt (
                  trans_export_statement (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Choice_abst_defi (
            (match v with
            | Alt (0, v) ->
                `Abst_defi (
                  trans_abstract_definition (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Prim_defi (
                  trans_primitive_definition (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Struct_defi (
                  trans_struct_definition (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Module_defi (
                  trans_module_definition (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Func_defi (
                  trans_function_definition (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `Macro_defi (
                  trans_macro_definition (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Typed_exp (
            trans_typed_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Comp_exp (
            trans_compound_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Pair_exp (
            trans_pair_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `COLON (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Macro_exp (
            trans_macro_expression (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Un_exp (
            trans_unary_expression (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Bin_exp (
            trans_binary_expression (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Tern_exp (
            trans_ternary_expression (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Gene_exp (
            trans_generator_expression (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Func_exp (
            trans_function_expression (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Coef_exp (
            trans_coefficient_expression (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Spread_exp (
            trans_spread_expression (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Range_exp (
            trans_range_expression (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Quote_exp (
            trans_quote_expression (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Interp_exp (
            trans_interpolation_expression (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Prim_exp (
            trans_primary_expression (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Lit (
            trans_literal (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `Op (
            trans_operator (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression_list ((kind, body) : mt) : CST.expression_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Assign_exp (
                  trans_assignment_expression (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Bare_tuple_exp (
                  trans_bare_tuple_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `LF (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `SEMI (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      (match v1 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Assign_exp (
                            trans_assignment_expression (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Bare_tuple_exp (
                            trans_bare_tuple_expression (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `LF (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `SEMI (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_field_expression ((kind, body) : mt) : CST.field_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_primary_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_finally_clause ((kind, body) : mt) : CST.finally_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `LF (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `SEMI (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_binding ((kind, body) : mt) : CST.for_binding =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Tuple_exp (
                  trans_tuple_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `In (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `EQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `UNKUNKUNK (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_clause ((kind, body) : mt) : CST.for_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_for_binding (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_for_binding (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_statement ((kind, body) : mt) : CST.for_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_for_binding (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_for_binding (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `LF (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `SEMI (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_definition ((kind, body) : mt) : CST.function_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_type_parameter_list (Run.matcher_token v))
              v2
            ,
            trans_parameter_list (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_expression ((kind, body) : mt) : CST.function_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Func_param_list_choice_exp_end (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_parameter_list (Run.matcher_token v1),
                  (match v2 with
                  | Alt (0, v) ->
                      `Exp (
                        trans_expression (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Assign_exp (
                        trans_assignment_expression (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Choice_id_DASHGT_choice_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Id (
                        trans_identifier (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Param_list (
                        trans_parameter_list (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.trans_token (Run.matcher_token v1),
                  (match v2 with
                  | Alt (0, v) ->
                      `Exp (
                        trans_expression (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Assign_exp (
                        trans_assignment_expression (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_generator_expression ((kind, body) : mt) : CST.generator_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            trans_comprehension_clause (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_clause ((kind, body) : mt) : CST.if_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_statement ((kind, body) : mt) : CST.if_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `LF (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `SEMI (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v3
            ,
            Run.repeat
              (fun v -> trans_elseif_clause (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v -> trans_else_clause (Run.matcher_token v))
              v5
            ,
            Run.trans_token (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interpolation_expression ((kind, body) : mt) : CST.interpolation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_keyword_parameters ((kind, body) : mt) : CST.keyword_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Spread_param (
                  trans_spread_parameter (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Opt_param (
                  trans_optional_parameter (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Typed_param (
                  trans_typed_parameter (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Id (
                            trans_identifier (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Spread_param (
                            trans_spread_parameter (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Opt_param (
                            trans_optional_parameter (Run.matcher_token v)
                          )
                      | Alt (3, v) ->
                          `Typed_param (
                            trans_typed_parameter (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_let_statement ((kind, body) : mt) : CST.let_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_variable_declaration (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_variable_declaration (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `LF (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `SEMI (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_literal ((kind, body) : mt) : CST.literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Int_lit (
            trans_integer_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Float_lit (
            trans_float_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Char_lit (
            trans_character_literal (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Cmd_lit (
            trans_command_literal (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Pref_str_lit (
            trans_prefixed_string_literal (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Pref_cmd_lit (
            trans_prefixed_command_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_macro_argument_list ((kind, body) : mt) : CST.macro_argument_list =
  match body with
  | Children v ->
      Run.repeat1
        (fun v -> trans_expression (Run.matcher_token v))
        v
  | Leaf _ -> assert false

and trans_macro_definition ((kind, body) : mt) : CST.macro_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Op (
                  trans_operator (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_parameter_list (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_macro_expression ((kind, body) : mt) : CST.macro_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_macro_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Imme_paren_arg_list (
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_immediate_paren (Run.matcher_token v0),
                            trans_argument_list (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `Macro_arg_list (
                      trans_macro_argument_list (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_matrix_expression ((kind, body) : mt) : CST.matrix_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_matrix_row (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_matrix_row (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_matrix_row ((kind, body) : mt) : CST.matrix_row =
  match body with
  | Children v ->
      Run.repeat1
        (fun v -> trans_expression (Run.matcher_token v))
        v
  | Leaf _ -> assert false

and trans_module_definition ((kind, body) : mt) : CST.module_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_named_field ((kind, body) : mt) : CST.named_field =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_optional_parameter ((kind, body) : mt) : CST.optional_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Typed_param (
                  trans_typed_parameter (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pair_expression ((kind, body) : mt) : CST.pair_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parameter_list ((kind, body) : mt) : CST.parameter_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Id (
                            trans_identifier (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Spread_param (
                            trans_spread_parameter (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Opt_param (
                            trans_optional_parameter (Run.matcher_token v)
                          )
                      | Alt (3, v) ->
                          `Typed_param (
                            trans_typed_parameter (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Id (
                                      trans_identifier (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Spread_param (
                                      trans_spread_parameter (Run.matcher_token v)
                                    )
                                | Alt (2, v) ->
                                    `Opt_param (
                                      trans_optional_parameter (Run.matcher_token v)
                                    )
                                | Alt (3, v) ->
                                    `Typed_param (
                                      trans_typed_parameter (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_keyword_parameters (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parameterized_identifier ((kind, body) : mt) : CST.parameterized_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Field_exp (
                  trans_field_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_type_argument_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parenthesized_expression ((kind, body) : mt) : CST.parenthesized_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Exp_list (
                  trans_expression_list (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Spread_exp (
                  trans_spread_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_primary_expression ((kind, body) : mt) : CST.primary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Array_exp (
            trans_array_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Array_comp_exp (
            trans_array_comprehension_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Matrix_exp (
            trans_matrix_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Call_exp (
            trans_call_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Field_exp (
            trans_field_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Paren_exp (
            trans_parenthesized_expression (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Subs_exp (
            trans_subscript_expression (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Para_id (
            trans_parameterized_identifier (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Tuple_exp (
            trans_tuple_expression (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Broa_call_exp (
            trans_broadcast_call_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_primitive_definition ((kind, body) : mt) : CST.primitive_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_parameter_list (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_subtype_clause (Run.matcher_token v))
              v4
            ,
            trans_pat_a25c544 (Run.matcher_token v5),
            Run.trans_token (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_quote_expression ((kind, body) : mt) : CST.quote_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_quote_statement ((kind, body) : mt) : CST.quote_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_range_expression ((kind, body) : mt) : CST.range_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_return_statement ((kind, body) : mt) : CST.return_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Exp (
                      trans_expression (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Bare_tuple_exp (
                      trans_bare_tuple_expression (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spread_expression ((kind, body) : mt) : CST.spread_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_string_interpolation ((kind, body) : mt) : CST.string_interpolation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_exp_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_expression (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_string_literal ((kind, body) : mt) : CST.string_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_string_start (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Str_content (
                      trans_string_content (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Str_interp (
                      trans_string_interpolation (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_string_end (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_struct_definition ((kind, body) : mt) : CST.struct_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_parameter_list (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_subtype_clause (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v5
            ,
            Run.trans_token (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_subscript_expression ((kind, body) : mt) : CST.subscript_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Prim_exp (
                  trans_primary_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Lit (
                  trans_literal (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_imm_tok_lbrack (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_expression (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_expression (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_subtype_clause ((kind, body) : mt) : CST.subtype_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ternary_expression ((kind, body) : mt) : CST.ternary_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_try_statement ((kind, body) : mt) : CST.try_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_catch_clause (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_finally_clause (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_tuple_expression ((kind, body) : mt) : CST.tuple_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Opt_COMMA (
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v
                )
            | Alt (1, v) ->
                `Choice_exp_COMMA (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        (match v0 with
                        | Alt (0, v) ->
                            `Exp (
                              trans_expression (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Named_field (
                              trans_named_field (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Choice_exp_rep1_COMMA_choice_exp_opt_COMMA (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        (match v0 with
                        | Alt (0, v) ->
                            `Exp (
                              trans_expression (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Named_field (
                              trans_named_field (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.repeat1
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  (match v1 with
                                  | Alt (0, v) ->
                                      `Exp (
                                        trans_expression (Run.matcher_token v)
                                      )
                                  | Alt (1, v) ->
                                      `Named_field (
                                        trans_named_field (Run.matcher_token v)
                                      )
                                  | _ -> assert false
                                  )
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                        ,
                        Run.opt
                          (fun v -> Run.trans_token (Run.matcher_token v))
                          v2
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_argument_list ((kind, body) : mt) : CST.type_argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parameter_list ((kind, body) : mt) : CST.type_parameter_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Cons_param (
                  trans_constrained_parameter (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Id (
                            trans_identifier (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Cons_param (
                            trans_constrained_parameter (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_typed_expression ((kind, body) : mt) : CST.typed_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `COLONCOLON (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LTCOLON (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v2 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Para_id (
                  trans_parameterized_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_typed_parameter ((kind, body) : mt) : CST.typed_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Para_id (
                  trans_parameterized_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_expression ((kind, body) : mt) : CST.unary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Un_op_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_unary_operator (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_SQUOT (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_variable_declaration ((kind, body) : mt) : CST.variable_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_while_statement ((kind, body) : mt) : CST.while_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `LF (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `SEMI (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> trans_expression_list (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_source_file ((kind, body) : mt) : CST.source_file =
  match body with
  | Children v ->
      Run.opt
        (fun v -> trans_expression_list (Run.matcher_token v))
        v
  | Leaf _ -> assert false



let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_source_file matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

